<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Ejercicio 2</title>
    <script src="scripts/jquery-3.3.1.js"></script>
    <script src="scripts/highcharts.js"></script>
    <script src="scripts/date.js"></script>
    <script src="scripts/exporting.js"></script>
</head>
<body>
    <div id="piechart" width="300" height="150"></div>
    <div id="linechart" width="300" height="150"></div>
    <script>
        $(document).ready(function GetJSON() {
                $.ajax({
                    url: 'http://s3.amazonaws.com/logtrust-static/test/test/data1.json',
                    type: 'GET',
                    dataType: 'JSON',
                    success: function (data) {
                        var categorias = new Hashtable();
                        var sizetable = data.length;
                        var encontrado = 0;
                        var sumatorio = new Hashtable();

                        for (var c = 0; c < sizetable; c++) {
                            encontrado = 0;
                            for (var i = 0; i <= categorias.size() ; i++) {
                                var CategoriaHashmap = (categorias.keys()[i]);
                                var CategoriaJSON = data[c]["cat"].toUpperCase();

                                if (CategoriaHashmap === CategoriaJSON) {

                                    var date = new Date(data[c]["d"]);
                                    date = date.getTime();
                                    categorias.get(data[c]["cat"].toUpperCase()).put(date, data[c]["value"]);
                                    var encontrado = 1;
                                }

                            }
                            if (encontrado === 0 && categorias.isEmpty() === false) {
                                var date = new Date(data[c]["d"]);
                                date = date.getTime();
                                categorias.put(data[c]["cat"].toUpperCase(), new Hashtable());
                                categorias.get(data[c]["cat"].toUpperCase()).put(date, data[c]["value"]);
                            }

                            if (categorias.isEmpty() === true) {
                                var date = new Date(data[c]["d"]);
                                date = date.getTime();
                                categorias.put(data[c]["cat"].toUpperCase(), new Hashtable());
                                categorias.get(data[c]["cat"].toUpperCase()).put(date, data[c]["value"]);
                            }
                        }
                        $.ajax({
                            url: 'http://s3.amazonaws.com/logtrust-static/test/test/data2.json',
                            type: 'GET',
                            dataType: 'JSON',
                            success: function (data) {

                                var sizetable = data.length;
                                var encontrado = 0;

                                for (var c = 0; c < sizetable; c++) {
                                    encontrado = 0;

                                    for (var i = 0; i <= categorias.size() ; i++) {
                                        var CategoriaHashmap = (categorias.keys()[i]);
                                        var CategoriaJSON = data[c]["categ"].toUpperCase();

                                        if (CategoriaHashmap === CategoriaJSON) {
                                            var date = new Date(data[c]["myDate"]);
                                            date = date.getTime();
                                            categorias.get(data[c]["categ"].toUpperCase()).put(date, data[c]["val"]);
                                            var encontrado = 1;
                                        }
                                    }
                                    if (encontrado === 0 && categorias.isEmpty() === false) {
                                        var date = new Date(data[c]["myDate"]);
                                        date = date.getTime();
                                        categorias.put(data[c]["categ"].toUpperCase(), new Hashtable());
                                        categorias.get(data[c]["categ"].toUpperCase()).put(date, data[c]["val"]);
                                    }

                                    if (categorias.isEmpty() === true) {
                                        var date = new Date(data[c]["myDate"]);
                                        date = date.getTime();
                                        categorias.put(data[c]["categ"].toUpperCase(), new Hashtable());
                                        categorias.get(data[c]["categ"].toUpperCase()).put(date, data[c]["val"]);
                                    }
                                }
                                $.ajax({
                                    url: 'http://s3.amazonaws.com/logtrust-static/test/test/data3.json',
                                    type: 'GET',
                                    dataType: 'JSON',
                                    success: function (data) {

                                        var sizetable = data.length;
                                        var encontrado = 0;

                                        for (var c = 0; c < sizetable; c++) {
                                            encontrado = 0;

                                            for (var i = 0; i <= categorias.size() ; i++) {
                                                var CategoriaHashmap = (categorias.keys()[i]);
                                                var CategoriaJSON = data[c]["raw"].match(/(?:CAT [0-9]+){1}/);
                                                CategoriaJSON = CategoriaJSON[0].toUpperCase();

                                                if (CategoriaHashmap === CategoriaJSON) {
                                                    var regexDATE = data[c]["raw"].match(/([12]\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01]))/);
                                                    var date = new Date(regexDATE[0]);
                                                    date = date.getTime();
                                                    categorias.get(CategoriaJSON).put(date, data[c]["val"]);
                                                    var encontrado = 1;
                                                }
                                            }
                                            if (encontrado === 0 && categorias.isEmpty() === false) {
                                                var regexDATE = data[c]["raw"].match(/([12]\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01]))/);
                                                var date = new Date(regexDATE[0]);
                                                date = date.getTime();

                                                categorias.put(CategoriaJSON.toUpperCase(), new Hashtable());
                                                categorias.get(CategoriaJSON).put(date, data[c]["val"]);
                                            }

                                            if (categorias.isEmpty() === true) {
                                                var regexDATE = data[c]["raw"].match(/([12]\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01]))/);
                                                var date = new Date(regexDATE[0]);
                                                date = date.getTime();

                                                categorias.put(CategoriaJSON.toUpperCase(), new Hashtable());
                                                categorias.get(CategoriaJSON).put(date, data[c]["val"]);
                                            }
                                        }
                                        var datos = [];
                                        for (var h = 0; h < categorias.size() ; h++) {
                                            var suma = 0;
                                            for (j = 0; j < categorias.get(categorias.keys()[h]).size() ; j++) {
                                                suma += categorias.get(categorias.keys()[h]).values()[j];
                                            }

                                            var serie = new Array(categorias.keys()[h], suma);
                                            datos.push(serie);
                                        }
                                        createPieChart(datos)
                                        createLineChart(categorias)
                                    }
                                });
                            }
                        });
                    }
                });
        });

        function createPieChart(series) {
            $('#piechart').highcharts(
                {
                    chart: {
                        plotBackgroundColor: null,
                        plotBorderWidth: null,
                        plotShadow: false,
                        type: 'pie'
                    },
                    title: {
                        text: 'Devo Categories by PieChart'

                    },
                    tooltip: {
                        pointFormat: '{series.name}: {point.y} (<b>{point.percentage:.1f}%</b>)'
                    },
                    plotOptions: {
                        pie: {
                            allowPointSelect: true,
                            cursor: 'pointer',
                            dataLabels: {
                                enabled: true,
                                format: '<b>{point.name}</b>: {point.percentage:.1f} %',
                                style: {
                                    color: (Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black'
                                }
                            }
                        }
                    },
                    series: [{
                        name: 'Total value',
                        colorByPoint: true,
                        data: series
                    }]

                });
        }

        function createLineChart(hashmap) {

            var key = hashmap.keys()[0];
            var general = [];
            var categories = [];
            var datos = [];

            for (var v = 0; v < hashmap.size() ; v++) {

                categories.push(hashmap.keys()[v]);

                var data = [];
                for (var w = 0; w < hashmap.get(hashmap.keys()[v]).size() ; w++) {
                    var serie1 = [];

                    serie1.push(hashmap.get(hashmap.keys()[v]).keys()[w], hashmap.get(hashmap.keys()[v]).values()[w]);
                    data.push(serie1);

                }
                general.push(data);
            }
            for (var x = 0; x < hashmap.size() ; x++) {
                general[x].sort(sortFunction);
                datos.push({
                    type: 'line',
                    name: categories[x],
                    data: general[x],
                    tooltip: {
                        valueDecimals: 2
                    }
                });
            }
            $('#linechart').highcharts(
                {
                    rangeSelector: {
                        selected: 1
                    },

                    title: {
                        text: 'Devo Categories by LineChart'
                    },
                    xAxis: {
                        type: 'datetime',
                        dateTimeLabelFormats: {
                            millisecond: '%H:%M:%S.%L',
                            second: '%H:%M:%S',
                            minute: '%H:%M',
                            hour: '%H:%M',
                            day: '%e. %b',
                            week: '%e. %b',
                            month: '%b \'%y',
                            year: '%Y'
                        }
                    },
                    yAxis: {
                        title: {
                            text: 'Values'
                        }
                    },
                    series: datos
                });
        }

        function sortFunction(a, b) {
            if (a[0] === b[0]) {
                return 0;
            }
            else {
                return (a[0] < b[0]) ? -1 : 1;
            }
        }
        var Hashtable = (function (UNDEFINED) {
            var FUNCTION = "function", STRING = "string", UNDEF = "undefined";

            // Require Array.prototype.splice, Object.prototype.hasOwnProperty and encodeURIComponent. In environments not
            // having these (e.g. IE <= 5), we bail out now and leave Hashtable null.
            if (typeof encodeURIComponent == UNDEF ||
                    Array.prototype.splice === UNDEFINED ||
                    Object.prototype.hasOwnProperty === UNDEFINED) {
                return null;
            }

            function toStr(obj) {
                return (typeof obj == STRING) ? obj : "" + obj;
            }

            function hashObject(obj) {
                var hashCode;
                if (typeof obj == STRING) {
                    return obj;
                } else if (typeof obj.hashCode == FUNCTION) {
                    // Check the hashCode method really has returned a string
                    hashCode = obj.hashCode();
                    return (typeof hashCode == STRING) ? hashCode : hashObject(hashCode);
                } else {
                    return toStr(obj);
                }
            }

            function merge(o1, o2) {
                for (var i in o2) {
                    if (o2.hasOwnProperty(i)) {
                        o1[i] = o2[i];
                    }
                }
            }

            function equals_fixedValueHasEquals(fixedValue, variableValue) {
                return fixedValue.equals(variableValue);
            }

            function equals_fixedValueNoEquals(fixedValue, variableValue) {
                return (typeof variableValue.equals == FUNCTION) ?
                    variableValue.equals(fixedValue) : (fixedValue === variableValue);
            }

            function createKeyValCheck(kvStr) {
                return function (kv) {
                    if (kv === null) {
                        throw new Error("null is not a valid " + kvStr);
                    } else if (kv === UNDEFINED) {
                        throw new Error(kvStr + " must not be undefined");
                    }
                };
            }

            var checkKey = createKeyValCheck("key"), checkValue = createKeyValCheck("value");

            /*----------------------------------------------------------------------------------------------------------------*/

            function Bucket(hash, firstKey, firstValue, equalityFunction) {
                this[0] = hash;
                this.entries = [];
                this.addEntry(firstKey, firstValue);

                if (equalityFunction !== null) {
                    this.getEqualityFunction = function () {
                        return equalityFunction;
                    };
                }
            }

            var EXISTENCE = 0, ENTRY = 1, ENTRY_INDEX_AND_VALUE = 2;

            function createBucketSearcher(mode) {
                return function (key) {
                    var i = this.entries.length, entry, equals = this.getEqualityFunction(key);
                    while (i--) {
                        entry = this.entries[i];
                        if (equals(key, entry[0])) {
                            switch (mode) {
                                case EXISTENCE:
                                    return true;
                                case ENTRY:
                                    return entry;
                                case ENTRY_INDEX_AND_VALUE:
                                    return [i, entry[1]];
                            }
                        }
                    }
                    return false;
                };
            }

            function createBucketLister(entryProperty) {
                return function (aggregatedArr) {
                    var startIndex = aggregatedArr.length;
                    for (var i = 0, entries = this.entries, len = entries.length; i < len; ++i) {
                        aggregatedArr[startIndex + i] = entries[i][entryProperty];
                    }
                };
            }

            Bucket.prototype = {
                getEqualityFunction: function (searchValue) {
                    return (typeof searchValue.equals == FUNCTION) ? equals_fixedValueHasEquals : equals_fixedValueNoEquals;
                },

                getEntryForKey: createBucketSearcher(ENTRY),

                getEntryAndIndexForKey: createBucketSearcher(ENTRY_INDEX_AND_VALUE),

                removeEntryForKey: function (key) {
                    var result = this.getEntryAndIndexForKey(key);
                    if (result) {
                        this.entries.splice(result[0], 1);
                        return result[1];
                    }
                    return null;
                },

                addEntry: function (key, value) {
                    this.entries.push([key, value]);
                },

                keys: createBucketLister(0),

                values: createBucketLister(1),

                getEntries: function (destEntries) {
                    var startIndex = destEntries.length;
                    for (var i = 0, entries = this.entries, len = entries.length; i < len; ++i) {
                        // Clone the entry stored in the bucket before adding to array
                        destEntries[startIndex + i] = entries[i].slice(0);
                    }
                },

                containsKey: createBucketSearcher(EXISTENCE),

                containsValue: function (value) {
                    var entries = this.entries, i = entries.length;
                    while (i--) {
                        if (value === entries[i][1]) {
                            return true;
                        }
                    }
                    return false;
                }
            };

            /*----------------------------------------------------------------------------------------------------------------*/

            // Supporting functions for searching hashtable buckets

            function searchBuckets(buckets, hash) {
                var i = buckets.length, bucket;
                while (i--) {
                    bucket = buckets[i];
                    if (hash === bucket[0]) {
                        return i;
                    }
                }
                return null;
            }

            function getBucketForHash(bucketsByHash, hash) {
                var bucket = bucketsByHash[hash];

                // Check that this is a genuine bucket and not something inherited from the bucketsByHash's prototype
                return (bucket && (bucket instanceof Bucket)) ? bucket : null;
            }

            /*----------------------------------------------------------------------------------------------------------------*/

            function Hashtable() {
                var buckets = [];
                var bucketsByHash = {};
                var properties = {
                    replaceDuplicateKey: true,
                    hashCode: hashObject,
                    equals: null
                };

                var arg0 = arguments[0], arg1 = arguments[1];
                if (arg1 !== UNDEFINED) {
                    properties.hashCode = arg0;
                    properties.equals = arg1;
                } else if (arg0 !== UNDEFINED) {
                    merge(properties, arg0);
                }

                var hashCode = properties.hashCode, equals = properties.equals;

                this.properties = properties;

                this.put = function (key, value) {
                    checkKey(key);
                    checkValue(value);
                    var hash = hashCode(key), bucket, bucketEntry, oldValue = null;

                    // Check if a bucket exists for the bucket key
                    bucket = getBucketForHash(bucketsByHash, hash);
                    if (bucket) {
                        // Check this bucket to see if it already contains this key
                        bucketEntry = bucket.getEntryForKey(key);
                        if (bucketEntry) {
                            // This bucket entry is the current mapping of key to value, so replace the old value.
                            // Also, we optionally replace the key so that the latest key is stored.
                            if (properties.replaceDuplicateKey) {
                                bucketEntry[0] = key;
                            }
                            oldValue = bucketEntry[1];
                            bucketEntry[1] = value;
                        } else {
                            // The bucket does not contain an entry for this key, so add one
                            bucket.addEntry(key, value);
                        }
                    } else {
                        // No bucket exists for the key, so create one and put our key/value mapping in
                        bucket = new Bucket(hash, key, value, equals);
                        buckets.push(bucket);
                        bucketsByHash[hash] = bucket;
                    }
                    return oldValue;
                };

                this.get = function (key) {
                    checkKey(key);

                    var hash = hashCode(key);

                    // Check if a bucket exists for the bucket key
                    var bucket = getBucketForHash(bucketsByHash, hash);
                    if (bucket) {
                        // Check this bucket to see if it contains this key
                        var bucketEntry = bucket.getEntryForKey(key);
                        if (bucketEntry) {
                            // This bucket entry is the current mapping of key to value, so return the value.
                            return bucketEntry[1];
                        }
                    }
                    return null;
                };

                this.containsKey = function (key) {
                    checkKey(key);
                    var bucketKey = hashCode(key);

                    // Check if a bucket exists for the bucket key
                    var bucket = getBucketForHash(bucketsByHash, bucketKey);

                    return bucket ? bucket.containsKey(key) : false;
                };

                this.containsValue = function (value) {
                    checkValue(value);
                    var i = buckets.length;
                    while (i--) {
                        if (buckets[i].containsValue(value)) {
                            return true;
                        }
                    }
                    return false;
                };

                this.clear = function () {
                    buckets.length = 0;
                    bucketsByHash = {};
                };

                this.isEmpty = function () {
                    return !buckets.length;
                };

                var createBucketAggregator = function (bucketFuncName) {
                    return function () {
                        var aggregated = [], i = buckets.length;
                        while (i--) {
                            buckets[i][bucketFuncName](aggregated);
                        }
                        return aggregated;
                    };
                };

                this.keys = createBucketAggregator("keys");
                this.values = createBucketAggregator("values");
                this.entries = createBucketAggregator("getEntries");

                this.remove = function (key) {
                    checkKey(key);

                    var hash = hashCode(key), bucketIndex, oldValue = null;

                    // Check if a bucket exists for the bucket key
                    var bucket = getBucketForHash(bucketsByHash, hash);

                    if (bucket) {
                        // Remove entry from this bucket for this key
                        oldValue = bucket.removeEntryForKey(key);
                        if (oldValue !== null) {
                            // Entry was removed, so check if bucket is empty
                            if (bucket.entries.length == 0) {
                                // Bucket is empty, so remove it from the bucket collections
                                bucketIndex = searchBuckets(buckets, hash);
                                buckets.splice(bucketIndex, 1);
                                delete bucketsByHash[hash];
                            }
                        }
                    }
                    return oldValue;
                };

                this.size = function () {
                    var total = 0, i = buckets.length;
                    while (i--) {
                        total += buckets[i].entries.length;
                    }
                    return total;
                };
            }

            Hashtable.prototype = {
                each: function (callback) {
                    var entries = this.entries(), i = entries.length, entry;
                    while (i--) {
                        entry = entries[i];
                        callback(entry[0], entry[1]);
                    }
                },

                equals: function (hashtable) {
                    var keys, key, val, count = this.size();
                    if (count == hashtable.size()) {
                        keys = this.keys();
                        while (count--) {
                            key = keys[count];
                            val = hashtable.get(key);
                            if (val === null || val !== this.get(key)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    return false;
                },

                putAll: function (hashtable, conflictCallback) {
                    var entries = hashtable.entries();
                    var entry, key, value, thisValue, i = entries.length;
                    var hasConflictCallback = (typeof conflictCallback == FUNCTION);
                    while (i--) {
                        entry = entries[i];
                        key = entry[0];
                        value = entry[1];

                        // Check for a conflict. The default behaviour is to overwrite the value for an existing key
                        if (hasConflictCallback && (thisValue = this.get(key))) {
                            value = conflictCallback(key, thisValue, value);
                        }
                        this.put(key, value);
                    }
                },

                clone: function () {
                    var clone = new Hashtable(this.properties);
                    clone.putAll(this);
                    return clone;
                }
            };

            Hashtable.prototype.toQueryString = function () {
                var entries = this.entries(), i = entries.length, entry;
                var parts = [];
                while (i--) {
                    entry = entries[i];
                    parts[i] = encodeURIComponent(toStr(entry[0])) + "=" + encodeURIComponent(toStr(entry[1]));
                }
                return parts.join("&");
            };

            return Hashtable;
        })();

        function getTimeStampAsString(timestamp) {
            date = new Date(timestamp);
            year = date.getFullYear();
            month = date.getMonth() + 1;
            month = month < 10 ? "0" + month : month;
            day = date.getDate();
            day = day < 10 ? "0" + day : day;
            return year + "-" + month + "-" + day;
        }
    </script>
</body>
</html>
